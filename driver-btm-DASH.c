/*
 * cgminer SPI driver for Bitmine.ch T3 devices
 *
 * Copyright 2013, 2014 Zefir Kurtisi <zefir.kurtisi@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 3 of the License, or (at your option)
 * any later version.  See COPYING for more details.
 */

#include <stdlib.h>
#include <assert.h>
#include <fcntl.h>
#include <limits.h>
#include <unistd.h>
#include <stdbool.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ioctl.h>

#include "spi-context.h"
#include "logging.h"
#include "miner.h"
#include "util.h"
#include "crc.h"

#include "T3-common.h"
#include "driver-btm-DASH.h"

struct spi_config cfg[ASIC_CHAIN_NUM];
struct spi_ctx *spi[ASIC_CHAIN_NUM];
struct T3_chain *chain[ASIC_CHAIN_NUM];

#define DISABLE_CHIP_FAIL_THRESHOLD	3
#define LEAST_CORE_ONE_CHAIN	400
#define RESET_CHAIN_CNT	2


static uint8_t A1Pll1=0;  //120MHz
static uint8_t A1Pll2=0;  //120MHz
static uint8_t A1Pll3=0;  //120MHz
static uint8_t A1Pll4=0;  //120MHz
static uint8_t A1Pll5=0;  //120MHz
static uint8_t A1Pll6=0;  //120MHz
static int T2spi[10];

int opt_diff=15;

static const uint8_t difficult_Tbl[24][8] = {
	{0x0f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff},	// 0.0625
	{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff},	// 1
	{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x7f},	// 2
	{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x3f},	// 4
	{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x1f},	// 8
	{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x0f},	// 16
	{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x07},	// 32
	{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x03},	// 64
	{0x1e, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},	// 256
	{0x1e, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff},	// 512
	{0x1e, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff},	// 1024
	{0x1e, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff},	// 2048
	{0x1e, 0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff},	// 4096
	{0x1e, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff},	// 8192
	{0x1e, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff},	// 16384
	{0x1e, 0x00, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff},	// 32768
	{0x1e, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff}	// 65536
};

const unsigned short wCRCTalbeAbss[] ={
0x0000, 0xCC01, 0xD801, 0x1400, 0xF001, 0x3C00, 0x2800, 0xE401, 0xA001, 0x6C00,
0x7800, 0xB401, 0x5000, 0x9C01, 0x8801, 0x4400,};

struct device_drv bitmineT3_drv;

unsigned short CRC16_2(unsigned char* pchMsg, unsigned short wDataLen)
{
	volatile unsigned short wCRC = 0xFFFF;
	unsigned short i;
	unsigned char chChar;

	for (i = 0; i < wDataLen; i++)
	{
		chChar = *pchMsg++;
		wCRC = wCRCTalbeAbss[(chChar ^ wCRC) & 15] ^ (wCRC >> 4);
		wCRC = wCRCTalbeAbss[((chChar >> 4) ^ wCRC) & 15] ^ (wCRC >> 4);
	}

	return wCRC;
}

unsigned short crc16(unsigned char* pchMsg, unsigned short wDataLen)
{
	unsigned short wCRC = 0xFFFF;
	unsigned short i;
	unsigned char chChar;
	unsigned short len = wDataLen / 2;
	unsigned char *tmp;
	unsigned short src[32];

	memset(src, 0, sizeof(src));
	for(i = 0; i < len; i++)
	{
		src[i] = ((((unsigned short)pchMsg[2* i]) << 8) & 0xff00) | ((unsigned short)pchMsg[2*i + 1] & 0x00ff);
	}
	tmp = (unsigned char*)src;
	for (i = 0; i < wDataLen; i++)
	{
		chChar = tmp[i];
		wCRC = wCRCTalbeAbss[(chChar ^ wCRC) & 15] ^ (wCRC >> 4); 
		wCRC = wCRCTalbeAbss[((chChar >> 4) ^ wCRC) & 15] ^ (wCRC >> 4); 
	}
	tmp = NULL;
	return wCRC;
}

int T3_ConfigT3PLLClock(int optPll)
{
	int i;
	int T3Pll;
	int PLL = optPll;

	if(PLL > 0)
	{
		T3Pll=0;
		if(PLL <= 120)
		{
			T3Pll = 0; //found
		}
		else
		{
			for(i = 1; i < T3_PLL_CLOCK_1400MHz; i++)
			{
				if((PLL < T3_REG_TO_CLOCK((i + 1))) && (PLL >= T3_REG_TO_CLOCK(i)))
				{
					T3Pll=i; //found
					break;
				}
			}
		}
	} else {
		T3Pll = 0;
	}

	return T3Pll;
}

/********** work queue */
static bool wq_enqueue(struct work_queue *wq, struct work *work)
{
	if (work == NULL)
		return false;
	struct work_ent *we = malloc(sizeof(*we));
	assert(we != NULL);
	we->work = work;
	INIT_LIST_HEAD(&we->head);
	list_add_tail(&we->head, &wq->head);
	wq->num_elems++;
	return true;
}

static struct work *wq_dequeue(struct work_queue *wq)
{
	if (wq == NULL)
		return NULL;
	if (wq->num_elems == 0)
		return NULL;
	struct work_ent *we;
	we = list_entry(wq->head.next, struct work_ent, head);
	struct work *work = we->work;

	list_del(&we->head);
	free(we);
	wq->num_elems--;
	return work;
}


static void applog_hexdumpd(char *prefix, uint8_t *buff, int len, int level)
{
	static char line[256];
	char *pos = line;
	int i;
	if (len < 1)
		return;

	pos += sprintf(pos, "%s: %d bytes:", prefix, len);
	for (i = 0; i < len; i++) {
		if (i > 0 && (i % 32) == 0) {
			applog(LOG_ERR, "%s", line);
			pos = line;
			pos += sprintf(pos, "\t");
		}
		pos += sprintf(pos, "%.2X ", buff[i]);
	}
	applog(level, "%s", line);
}

static void hexdumpd(char *prefix, uint8_t *buff, int len)
{
	applog_hexdumpd(prefix, buff, len, LOG_ERR);
}

/********** temporary helper for hexdumping SPI traffic */
static void applog_hexdump(char *prefix, uint8_t *buff, int len, int level)
{
	static char line[256];
	char *pos = line;
	int i;
	if (len < 1)
		return;

	pos += sprintf(pos, "%s: %d bytes:", prefix, len);
	for (i = 0; i < len; i++) {
		if (i > 0 && (i % 32) == 0) {
			applog(LOG_DEBUG, "%s", line);
			pos = line;
			pos += sprintf(pos, "\t");
		}
		pos += sprintf(pos, "%.2X ", buff[i]);
	}
	applog(level, "%s", line);
}

static void hexdump(char *prefix, uint8_t *buff, int len)
{
	applog_hexdump(prefix, buff, len, LOG_DEBUG);
}

static void hexdump_error(char *prefix, uint8_t *buff, int len)
{
	applog_hexdump(prefix, buff, len, LOG_ERR);
}

static void flush_spi(struct T3_chain *t3)
{
	memset(t3->spi_tx, 0, 64);
	spi_transfer(t3->spi_ctx, t3->spi_tx, t3->spi_rx, 64);
}


/********** upper layer SPI functions */
static uint8_t *exec_cmd(struct T3_chain *t3,
			  uint8_t cmd, uint8_t chip_id,
			  uint8_t *data, uint8_t len,
			  uint8_t resp_len)
{
	int tx_len = 4 + len;
	memset(t3->spi_tx, 0, tx_len);
	t3->spi_tx[0] = cmd;
	t3->spi_tx[1] = chip_id;

	if (data != NULL)
		memcpy(t3->spi_tx + 2, data, len);

	assert(spi_transfer(t3->spi_ctx, t3->spi_tx, t3->spi_rx, tx_len));
	//hexdump("send: TX", t3->spi_tx, tx_len);
	//hexdump("send: RX", t3->spi_rx, tx_len);

	int poll_len = resp_len;
	if (chip_id == 0) {
		if (t3->num_chips == 0) {
			applog(LOG_INFO, "%d: unknown chips in chain, "
			       "assuming 8", t3->chain_id);
			poll_len += 32;
		}
		poll_len += 4 * t3->num_chips;
	}
	else {
		poll_len += 4 * chip_id - 2;
	}
	assert(spi_transfer(t3->spi_ctx, NULL, t3->spi_rx + tx_len, poll_len));
	//hexdump("poll: RX", t3->spi_rx + tx_len, poll_len);
	int ack_len = tx_len + resp_len;
	int ack_pos = tx_len + poll_len - ack_len;
	//hexdump("poll: ACK", t3->spi_rx + ack_pos, ack_len - 2);

	return (t3->spi_rx + ack_pos);

}


/********** T3 SPI commands */
static uint8_t *cmd_BIST_FIX_BCAST(struct T3_chain *t3)
{
	uint8_t *ret = exec_cmd(t3, T3_BIST_FIX, 0x00, NULL, 0, 0);
	if (ret == NULL || ret[0] != T3_BIST_FIX) {
		applog(LOG_ERR, "%d: cmd_BIST_FIX_BCAST failed", t3->chain_id);
		return NULL;
	}
	return ret;
}

static uint8_t *cmd_BIST_FIX_NN(struct T3_chain *t3, int chip)
{
	uint8_t *ret = exec_cmd(t3, T3_BIST_FIX, chip, NULL, 0, 0);
	if (ret == NULL || ret[0] != T3_BIST_FIX) {
		applog(LOG_ERR, "%d: cmd_BIST_FIX_BCAST failed", t3->chain_id);
		return NULL;
	}
	return ret;
}

static uint8_t *cmd_BIST_COLLECT_BCAST(struct T3_chain *t3)
{
	uint8_t *ret = exec_cmd(t3, T3_BIST_COLLECT, 0x00, NULL, 0, 0);
	if (ret == NULL || ret[0] != T3_BIST_COLLECT) {
		applog(LOG_ERR, "%d: cmd_BIST_COLLECT_BCAST failed", t3->chain_id);
		return NULL;
	}
	return ret;
}

static uint8_t *cmd_RESET_BCAST(struct T3_chain *t3, uint8_t strategy)
{
	static uint8_t s[2];
	s[0] = strategy;
	s[1] = strategy;
	uint8_t *ret = exec_cmd(t3, T3_RESET, 0x00, s, 2, 0);
	if (ret == NULL || (ret[0] != T3_RESET_RES && t3->num_chips != 0)) {
		applog(LOG_ERR, "%d: cmd_RESET_BCAST failed", t3->chain_id);
		return NULL;
	}
	return ret;
}

static uint8_t *cmd_RESET_IDUAL(struct T3_chain *t3, uint8_t chip_id)
{
	static uint8_t s[2];
	s[0] = 0xe5;
	s[1] = 0xe5;
	uint8_t *ret = exec_cmd(t3, T3_RESET, chip_id, s, 2, 0);
	if (ret == NULL || (ret[0] != T3_RESET && ret[1] != chip_id)) {
		applog(LOG_ERR, "%d: cmd_RESET_BCAST failed", t3->chain_id);
		return NULL;
	}
	return ret;
}

static uint8_t *cmd_READ_RESULT_BCAST(struct T3_chain *t3)
{
	int tx_len = 10;
	uint16_t clc_crc;
	uint16_t res_crc;
	memset(t3->spi_tx, 0, tx_len);
	t3->spi_tx[0] = T3_READ_RESULT;

	assert(spi_transfer(t3->spi_ctx, t3->spi_tx, t3->spi_rx, tx_len));
//	hexdump("send: TX", t3->spi_tx, tx_len);
//	hexdump("send: RX", t3->spi_rx, tx_len);

	int poll_len = tx_len + 4 * t3->num_chips;
	assert(spi_transfer(t3->spi_ctx, NULL, t3->spi_rx + tx_len, poll_len));
//	hexdump("poll: RX", t3->spi_rx + tx_len, poll_len);

	uint8_t *scan = t3->spi_rx;

	int i;
	for (i = 0; i < poll_len; i += 2) {
		if ((scan[i] & 0x0f) == T3_READ_RESULT && (scan[i] & 0xf0) != 0) {
			res_crc = (scan[i + ASIC_RESULT_LEN] << 8) + (scan[i + ASIC_RESULT_LEN+1] << 0);
			clc_crc = crc16(scan + i, ASIC_RESULT_LEN);
				if(clc_crc == res_crc)
					return scan + i;
		}
	}
	
	return NULL;
}

static uint8_t *cmd_WRITE_REG(struct T3_chain *t3, uint8_t chip, uint8_t *reg)
{	
	uint8_t buffer[14];
	uint8_t reg_crc[14];

	buffer[0] = 0x09;
	buffer[1] = chip;
	memcpy(buffer + 2, reg, 12);

	unsigned short crc = crc16(buffer, 14);

	memcpy(reg_crc, reg, 12);
	reg_crc[12] = (crc >> 8) & 0xff;
	reg_crc[13] = crc & 0xff;
	
	uint8_t *ret = exec_cmd(t3, T3_WRITE_REG, chip, reg_crc, 14, 0);
	if (ret == NULL || ret[0] != T3_WRITE_REG) {
		applog(LOG_ERR, "%d: cmd_WRITE_REG failed", t3->chain_id);
		return NULL;
	}

	return ret;
}

static uint8_t *cmd_READ_REG(struct T3_chain *t3, uint8_t chip)
{
	uint8_t *ret = exec_cmd(t3, T3_READ_REG, chip, NULL, 14, 18);
	unsigned short crc = ((((unsigned short)ret[14]) << 8) & 0xff00) | ((unsigned short)ret[15] & 0x00ff);
	if (ret == NULL || ret[0] != T3_READ_REG_RESP || ret[1] != chip || crc != crc16(ret, 14)) {
		applog(LOG_ERR, "%d: cmd_READ_REG chip %d failed",
		       t3->chain_id, chip);
		return NULL;
	}
	memcpy(t3->spi_rx, ret, 16);
	return ret;
}

uint8_t cmd_CHECK_BUSY(struct T3_chain *t3, uint8_t chip_id)
{
	//printf("[check busy] \r\n");
	
	if(cmd_READ_REG(t3, chip_id) && (t3->spi_rx[11] & 0x01) == 1)
	{
		//applog(LOG_WARNING, "chip %d is busy now", chip_id);
		return WORK_BUSY;
	}
	//applog(LOG_WARNING, "chip %d is free now", chip_id);
	return WORK_FREE;
}

static bool cmd_WRITE_JOB(struct T3_chain *t3, uint8_t chip_id,
			      uint8_t *job)
{
	/* ensure we push the SPI command to the last chip in chain */
	int tx_len = JOB_LENGTH + 2;
	memcpy(t3->spi_tx, job, JOB_LENGTH);
	memset(t3->spi_tx + JOB_LENGTH, 0, tx_len - JOB_LENGTH);

	assert(spi_transfer(t3->spi_ctx, t3->spi_tx, t3->spi_rx, tx_len));

	int poll_len = 4 * chip_id - 2;

	assert(spi_transfer(t3->spi_ctx, NULL, t3->spi_rx + tx_len, poll_len));

//	int ack_len = tx_len;
//	int ack_pos = tx_len + poll_len - ack_len;
//	hexdump("poll: ACK", t3->spi_rx + ack_pos, tx_len);

	printf("[write job] \r\n");
	hexdumpd("job:", t3->spi_tx, JOB_LENGTH);

	cgsleep_us(1000);

	if(cmd_CHECK_BUSY(t3, chip_id) != WORK_BUSY)
	{
		return false;
	}

	return true;

}

/********** T3 low level functions */
#define MAX_PLL_WAIT_CYCLES 25
#define PLL_CYCLE_WAIT_TIME 40
static bool check_chip_pll_lock(struct T3_chain *t3, int chip_id, uint8_t *wr)
{
	int n;
	for (n = 0; n < MAX_PLL_WAIT_CYCLES; n++) {
		/* check for PLL lock status */

		if (cmd_READ_REG(t3, chip_id) && (t3->spi_rx[4] & 0x01) == 1) {
			/* double check that we read back what we set before */

			return wr[0] == t3->spi_rx[2] && wr[1] == t3->spi_rx[3] && wr[3] == t3->spi_rx[5];
		}
	}
	applog(LOG_ERR, "%d: chip %d failed PLL lock", t3->chain_id, chip_id);
	return false;
}


static int chain_chips(struct T3_chain *t3)
{
	int tx_len = 6;
	int rx_len = 4;
	int cid = t3->chain_id;

	memset(t3->spi_tx, 0, tx_len);
	memset(t3->spi_rx, 0, rx_len); 
	t3->spi_tx[0] = T3_BIST_START;
	t3->spi_tx[1] = 0;

	struct spi_ctx *spi = t3->spi_ctx;

	if (!spi_transfer(t3->spi_ctx, t3->spi_tx, t3->spi_rx, 6))
		return 0;
	hexdump("TX", t3->spi_tx, 6);
	hexdump("RX", t3->spi_rx, 6);

	int i;
	int max_poll_words = MAX_CHAIN_LENGTH * 2;

	for(i = 0; i < max_poll_words; i++) {
		if (t3->spi_rx[0] == T3_BIST_START && t3->spi_rx[1] == 0) {
			spi_transfer(t3->spi_ctx, NULL, t3->spi_rx, 2);
			hexdump("TX", t3->spi_tx, 2);
			uint8_t n = t3->spi_rx[1];
			t3->num_chips = (i / 2) + 1;
			if(t3->num_chips != n) {
				applog(LOG_ERR, "%d: enumeration: %d <-> %d",cid, t3->num_chips, n);
				if(n != 0)
					t3->num_active_chips = n;
			}
			applog(LOG_WARNING, "%d: detected %d chips", cid, t3->num_chips);
			return t3->num_chips;
		}
		bool s = spi_transfer(t3->spi_ctx, NULL, t3->spi_rx, 2);
		hexdump("RX", t3->spi_rx, 2);
		if(!s)
			return 0;
	}
	applog(LOG_WARNING, "%d: no T3 chip-chain detected", cid);
	return 0;
}


static const uint8_t default_reg[][13] =
{
	
	{ 0x02, 0x50, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0120MHz, VCO=0960MHz

	{ 0x06, 0xf2, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0121MHz, VCO=0968MHz
	{ 0x06, 0xf4, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0122MHz, VCO=0976MHz
	{ 0x06, 0xf6, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0123MHz, VCO=0984MHz
	{ 0x06, 0xf8, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0124MHz, VCO=0992MHz
	{ 0x06, 0xfa, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0125MHz, VCO=1000MHz
	{ 0x06, 0xfc, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0126MHz, VCO=1008MHz
	{ 0x06, 0xfe, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0127MHz, VCO=1016MHz

	{ 0x07, 0x00, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0128MHz, VCO=1024MHz
	{ 0x07, 0x02, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0129MHz, VCO=1032MHz
	{ 0x07, 0x04, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0130MHz, VCO=1040MHz
	{ 0x07, 0x06, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0131MHz, VCO=1048MHz
	{ 0x07, 0x08, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0132MHz, VCO=1056MHz
	{ 0x07, 0x0a, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0133MHz, VCO=1064MHz
	{ 0x07, 0x0c, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0134MHz, VCO=1072MHz
	{ 0x07, 0x0e, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0135MHz, VCO=1080MHz
	{ 0x07, 0x10, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0136MHz, VCO=1088MHz
	{ 0x07, 0x12, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0137MHz, VCO=1096MHz
	{ 0x07, 0x14, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0138MHz, VCO=1104MHz
	{ 0x07, 0x16, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0139MHz, VCO=1112MHz
	{ 0x07, 0x18, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0140MHz, VCO=1120MHz
	{ 0x07, 0x1a, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0141MHz, VCO=1128MHz
	{ 0x07, 0x1c, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0142MHz, VCO=1136MHz
	{ 0x07, 0x1e, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0143MHz, VCO=1144MHz
	{ 0x07, 0x20, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0144MHz, VCO=1152MHz
	{ 0x07, 0x22, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0145MHz, VCO=1160MHz
	{ 0x07, 0x24, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0146MHz, VCO=1168MHz
	{ 0x07, 0x26, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0147MHz, VCO=1176MHz
	{ 0x07, 0x28, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0148MHz, VCO=1184MHz
	{ 0x07, 0x2a, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0149MHz, VCO=1192MHz
	{ 0x07, 0x2c, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0150MHz, VCO=1200MHz
	{ 0x07, 0x2e, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0151MHz, VCO=1208MHz
	{ 0x07, 0x30, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0152MHz, VCO=1216MHz
	{ 0x07, 0x32, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0153MHz, VCO=1224MHz
	{ 0x07, 0x34, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0154MHz, VCO=1232MHz
	{ 0x07, 0x36, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0155MHz, VCO=1240MHz
	{ 0x07, 0x38, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0156MHz, VCO=1248MHz
	{ 0x07, 0x3a, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0157MHz, VCO=1256MHz
	{ 0x07, 0x3c, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0158MHz, VCO=1264MHz
	{ 0x07, 0x3e, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0159MHz, VCO=1272MHz
	{ 0x07, 0x40, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0160MHz, VCO=1280MHz
	{ 0x07, 0x42, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0161MHz, VCO=1288MHz
	{ 0x07, 0x44, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0162MHz, VCO=1296MHz
	{ 0x07, 0x46, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0163MHz, VCO=1304MHz
	{ 0x07, 0x48, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0164MHz, VCO=1312MHz
	{ 0x07, 0x4a, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0165MHz, VCO=1320MHz
	{ 0x07, 0x4c, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0166MHz, VCO=1328MHz
	{ 0x07, 0x4e, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0167MHz, VCO=1336MHz
	{ 0x07, 0x50, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0168MHz, VCO=1344MHz
	{ 0x07, 0x52, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0169MHz, VCO=1352MHz
	{ 0x07, 0x54, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0170MHz, VCO=1360MHz
	{ 0x07, 0x56, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0171MHz, VCO=1368MHz
	{ 0x07, 0x58, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0172MHz, VCO=1376MHz
	{ 0x07, 0x5a, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0173MHz, VCO=1384MHz
	{ 0x07, 0x5c, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0174MHz, VCO=1392MHz
	{ 0x07, 0x5e, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0175MHz, VCO=1400MHz
	{ 0x07, 0x60, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0176MHz, VCO=1408MHz
	{ 0x07, 0x62, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0177MHz, VCO=1416MHz
	{ 0x07, 0x64, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0178MHz, VCO=1424MHz
	{ 0x07, 0x66, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0179MHz, VCO=1432MHz
	{ 0x07, 0x68, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0180MHz, VCO=1440MHz
	{ 0x07, 0x6a, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0181MHz, VCO=1448MHz
	{ 0x07, 0x6c, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0182MHz, VCO=1456MHz
	{ 0x07, 0x6e, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0183MHz, VCO=1464MHz
	{ 0x07, 0x70, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0184MHz, VCO=1472MHz
	{ 0x07, 0x72, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0185MHz, VCO=1480MHz
	{ 0x07, 0x74, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0186MHz, VCO=1488MHz
	{ 0x07, 0x76, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0187MHz, VCO=1496MHz
	{ 0x07, 0x78, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0188MHz, VCO=1504MHz
	{ 0x07, 0x7a, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0189MHz, VCO=1512MHz
	{ 0x07, 0x7c, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0190MHz, VCO=1520MHz
	{ 0x07, 0x7e, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0191MHz, VCO=1528MHz
	{ 0x07, 0x80, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0192MHz, VCO=1536MHz
	{ 0x07, 0x82, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0193MHz, VCO=1544MHz
	{ 0x07, 0x84, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0194MHz, VCO=1552MHz
	{ 0x07, 0x86, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0195MHz, VCO=1560MHz
	{ 0x07, 0x88, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0196MHz, VCO=1568MHz
	{ 0x07, 0x8a, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0197MHz, VCO=1576MHz
	{ 0x07, 0x8c, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0198MHz, VCO=1584MHz
	{ 0x07, 0x8e, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0199MHz, VCO=1592MHz
	{ 0x07, 0x90, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0200MHz, VCO=1600MHz
	{ 0x07, 0x92, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0201MHz, VCO=1608MHz
	{ 0x07, 0x94, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0202MHz, VCO=1616MHz
	{ 0x07, 0x96, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0203MHz, VCO=1624MHz
	{ 0x07, 0x98, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0204MHz, VCO=1632MHz
	{ 0x07, 0x9a, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0205MHz, VCO=1640MHz
	{ 0x07, 0x9c, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0206MHz, VCO=1648MHz
	{ 0x07, 0x9e, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0207MHz, VCO=1656MHz
	{ 0x07, 0xa0, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0208MHz, VCO=1664MHz
	{ 0x07, 0xa2, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0209MHz, VCO=1672MHz
	{ 0x07, 0xa4, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0210MHz, VCO=1680MHz
	{ 0x07, 0xa6, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0211MHz, VCO=1688MHz
	{ 0x07, 0xa8, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0212MHz, VCO=1696MHz
	{ 0x07, 0xaa, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0213MHz, VCO=1704MHz
	{ 0x07, 0xac, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0214MHz, VCO=1712MHz
	{ 0x07, 0xae, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0215MHz, VCO=1720MHz
	{ 0x07, 0xb0, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0216MHz, VCO=1728MHz
	{ 0x07, 0xb2, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0217MHz, VCO=1736MHz
	{ 0x07, 0xb4, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0218MHz, VCO=1744MHz
	{ 0x07, 0xb6, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0219MHz, VCO=1752MHz
	{ 0x07, 0xb8, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0220MHz, VCO=1760MHz
	{ 0x07, 0xba, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0221MHz, VCO=1768MHz
	{ 0x07, 0xbc, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0222MHz, VCO=1776MHz
	{ 0x07, 0xbe, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0223MHz, VCO=1784MHz
	{ 0x07, 0xc0, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0224MHz, VCO=1792MHz
	{ 0x07, 0xc2, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0225MHz, VCO=1800MHz
	{ 0x07, 0xc4, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0226MHz, VCO=1808MHz
	{ 0x07, 0xc6, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0227MHz, VCO=1816MHz
	{ 0x07, 0xc8, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0228MHz, VCO=1824MHz
	{ 0x07, 0xca, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0229MHz, VCO=1832MHz
	{ 0x07, 0xcc, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0230MHz, VCO=1840MHz
	{ 0x07, 0xce, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0231MHz, VCO=1848MHz
	{ 0x07, 0xd0, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0232MHz, VCO=1856MHz
	{ 0x07, 0xd2, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0233MHz, VCO=1864MHz
	{ 0x07, 0xd4, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0234MHz, VCO=1872MHz
	{ 0x07, 0xd6, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0235MHz, VCO=1880MHz
	{ 0x07, 0xd8, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0236MHz, VCO=1888MHz
	{ 0x07, 0xda, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0237MHz, VCO=1896MHz
	{ 0x07, 0xdc, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0238MHz, VCO=1904MHz
	{ 0x07, 0xde, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0239MHz, VCO=1912MHz
	{ 0x07, 0xe0, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0240MHz, VCO=1920MHz
	{ 0x07, 0xe2, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0241MHz, VCO=1928MHz
	{ 0x07, 0xe4, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0242MHz, VCO=1936MHz
	{ 0x07, 0xe6, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0243MHz, VCO=1944MHz
	{ 0x07, 0xe8, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0244MHz, VCO=1952MHz
	{ 0x07, 0xea, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0245MHz, VCO=1960MHz
	{ 0x07, 0xec, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0246MHz, VCO=1968MHz
	{ 0x07, 0xee, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0247MHz, VCO=1976MHz
	{ 0x07, 0xf0, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0248MHz, VCO=1984MHz
	{ 0x07, 0xf2, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0249MHz, VCO=1992MHz
	{ 0x07, 0xf4, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0250MHz, VCO=2000MHz
	{ 0x07, 0xf6, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0251MHz, VCO=2008MHz
	{ 0x07, 0xf8, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0252MHz, VCO=2016MHz
	{ 0x07, 0xfa, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0253MHz, VCO=2024MHz
	{ 0x07, 0xfc, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0254MHz, VCO=2032MHz
	{ 0x07, 0xfe, 0x40, 0xc2, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0255MHz, VCO=2040MHz

	{ 0x07, 0x01, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0257MHz, VCO=1028MHz
	{ 0x07, 0x03, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0259MHz, VCO=1036MHz
	{ 0x07, 0x05, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0261MHz, VCO=1044MHz
	{ 0x07, 0x07, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0263MHz, VCO=1052MHz
	{ 0x07, 0x09, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0265MHz, VCO=1060MHz
	{ 0x07, 0x0b, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0267MHz, VCO=1068MHz
	{ 0x07, 0x0d, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0269MHz, VCO=1076MHz
	{ 0x07, 0x0f, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0271MHz, VCO=1084MHz
	{ 0x07, 0x11, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0273MHz, VCO=1092MHz
	{ 0x07, 0x13, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0275MHz, VCO=1100MHz
	{ 0x07, 0x15, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0277MHz, VCO=1108MHz
	{ 0x07, 0x17, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0279MHz, VCO=1116MHz
	{ 0x07, 0x19, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0281MHz, VCO=1124MHz
	{ 0x07, 0x1b, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0283MHz, VCO=1132MHz
	{ 0x07, 0x1d, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0285MHz, VCO=1140MHz
	{ 0x07, 0x1f, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0287MHz, VCO=1148MHz
	{ 0x07, 0x21, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0289MHz, VCO=1156MHz
	{ 0x07, 0x23, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0291MHz, VCO=1164MHz
	{ 0x07, 0x25, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0293MHz, VCO=1172MHz
	{ 0x07, 0x27, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0295MHz, VCO=1180MHz
	{ 0x07, 0x29, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0297MHz, VCO=1188MHz
	{ 0x07, 0x2b, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0299MHz, VCO=1196MHz
	{ 0x07, 0x2d, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0301MHz, VCO=1204MHz
	{ 0x07, 0x2f, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0303MHz, VCO=1212MHz
	{ 0x07, 0x31, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0305MHz, VCO=1220MHz
	{ 0x07, 0x33, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0307MHz, VCO=1228MHz
	{ 0x07, 0x35, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0309MHz, VCO=1236MHz
	{ 0x07, 0x37, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0311MHz, VCO=1244MHz
	{ 0x07, 0x39, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0313MHz, VCO=1252MHz
	{ 0x07, 0x3b, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0315MHz, VCO=1260MHz
	{ 0x07, 0x3d, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0317MHz, VCO=1268MHz
	{ 0x07, 0x3f, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0319MHz, VCO=1276MHz
	{ 0x07, 0x41, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0321MHz, VCO=1284MHz
	{ 0x07, 0x43, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0323MHz, VCO=1292MHz
	{ 0x07, 0x45, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0325MHz, VCO=1300MHz
	{ 0x07, 0x47, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0327MHz, VCO=1308MHz
	{ 0x07, 0x49, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0329MHz, VCO=1316MHz
	{ 0x07, 0x4b, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0331MHz, VCO=1324MHz
	{ 0x07, 0x4d, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0333MHz, VCO=1332MHz
	{ 0x07, 0x4f, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0335MHz, VCO=1340MHz
	{ 0x07, 0x51, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0337MHz, VCO=1348MHz
	{ 0x07, 0x53, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0339MHz, VCO=1356MHz
	{ 0x07, 0x55, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0341MHz, VCO=1364MHz
	{ 0x07, 0x57, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0343MHz, VCO=1372MHz
	{ 0x07, 0x59, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0345MHz, VCO=1380MHz
	{ 0x07, 0x5b, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0347MHz, VCO=1388MHz
	{ 0x07, 0x5d, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0349MHz, VCO=1396MHz
	{ 0x07, 0x5f, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0351MHz, VCO=1404MHz
	{ 0x07, 0x61, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0353MHz, VCO=1412MHz
	{ 0x07, 0x63, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0355MHz, VCO=1420MHz
	{ 0x07, 0x65, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0357MHz, VCO=1428MHz
	{ 0x07, 0x67, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0359MHz, VCO=1436MHz
	{ 0x07, 0x69, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0361MHz, VCO=1444MHz
	{ 0x07, 0x6b, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0363MHz, VCO=1452MHz
	{ 0x07, 0x6d, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0365MHz, VCO=1460MHz
	{ 0x07, 0x6f, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0367MHz, VCO=1468MHz
	{ 0x07, 0x71, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0369MHz, VCO=1476MHz
	{ 0x07, 0x73, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0371MHz, VCO=1484MHz
	{ 0x07, 0x75, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0373MHz, VCO=1492MHz
	{ 0x07, 0x77, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0375MHz, VCO=1500MHz
	{ 0x07, 0x79, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0377MHz, VCO=1508MHz
	{ 0x07, 0x7b, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0379MHz, VCO=1516MHz
	{ 0x07, 0x7d, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0381MHz, VCO=1524MHz
	{ 0x07, 0x7f, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0383MHz, VCO=1532MHz
	{ 0x07, 0x81, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0385MHz, VCO=1540MHz
	{ 0x07, 0x83, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0387MHz, VCO=1548MHz
	{ 0x07, 0x85, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0389MHz, VCO=1556MHz
	{ 0x07, 0x87, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0391MHz, VCO=1564MHz
	{ 0x07, 0x89, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0393MHz, VCO=1572MHz
	{ 0x07, 0x8b, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0395MHz, VCO=1580MHz
	{ 0x07, 0x8d, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0397MHz, VCO=1588MHz
	{ 0x07, 0x8f, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0399MHz, VCO=1596MHz
	{ 0x07, 0x91, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0401MHz, VCO=1604MHz
	{ 0x07, 0x93, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0403MHz, VCO=1612MHz
	{ 0x07, 0x95, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0405MHz, VCO=1620MHz
	{ 0x07, 0x97, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0407MHz, VCO=1628MHz
	{ 0x07, 0x99, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0409MHz, VCO=1636MHz
	{ 0x07, 0x9b, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0411MHz, VCO=1644MHz
	{ 0x07, 0x9d, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0413MHz, VCO=1652MHz
	{ 0x07, 0x9f, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0415MHz, VCO=1660MHz
	{ 0x07, 0xa1, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0417MHz, VCO=1668MHz
	{ 0x07, 0xa3, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0419MHz, VCO=1676MHz
	{ 0x07, 0xa5, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0421MHz, VCO=1684MHz
	{ 0x07, 0xa7, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0423MHz, VCO=1692MHz
	{ 0x07, 0xa9, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0425MHz, VCO=1700MHz
	{ 0x07, 0xab, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0427MHz, VCO=1708MHz
	{ 0x07, 0xad, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0429MHz, VCO=1716MHz
	{ 0x07, 0xaf, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0431MHz, VCO=1724MHz
	{ 0x07, 0xb1, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0433MHz, VCO=1732MHz
	{ 0x07, 0xb3, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0435MHz, VCO=1740MHz
	{ 0x07, 0xb5, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0437MHz, VCO=1748MHz
	{ 0x07, 0xb7, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0439MHz, VCO=1756MHz
	{ 0x07, 0xb9, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0441MHz, VCO=1764MHz
	{ 0x07, 0xbb, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0443MHz, VCO=1772MHz
	{ 0x07, 0xbd, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0445MHz, VCO=1780MHz
	{ 0x07, 0xbf, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0447MHz, VCO=1788MHz
	{ 0x07, 0xc1, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0449MHz, VCO=1796MHz
	{ 0x07, 0xc3, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0451MHz, VCO=1804MHz
	{ 0x07, 0xc5, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0453MHz, VCO=1812MHz
	{ 0x07, 0xc7, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0455MHz, VCO=1820MHz
	{ 0x07, 0xc9, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0457MHz, VCO=1828MHz
	{ 0x07, 0xcb, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0459MHz, VCO=1836MHz
	{ 0x07, 0xcd, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0461MHz, VCO=1844MHz
	{ 0x07, 0xcf, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0463MHz, VCO=1852MHz
	{ 0x07, 0xd1, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0465MHz, VCO=1860MHz
	{ 0x07, 0xd3, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0467MHz, VCO=1868MHz
	{ 0x07, 0xd5, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0469MHz, VCO=1876MHz
	{ 0x07, 0xd7, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0471MHz, VCO=1884MHz
	{ 0x07, 0xd9, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0473MHz, VCO=1892MHz
	{ 0x07, 0xdb, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0475MHz, VCO=1900MHz
	{ 0x07, 0xdd, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0477MHz, VCO=1908MHz
	{ 0x07, 0xdf, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0479MHz, VCO=1916MHz
	{ 0x07, 0xe1, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0481MHz, VCO=1924MHz
	{ 0x07, 0xe3, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0483MHz, VCO=1932MHz
	{ 0x07, 0xe5, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0485MHz, VCO=1940MHz
	{ 0x07, 0xe7, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0487MHz, VCO=1948MHz
	{ 0x07, 0xe9, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0489MHz, VCO=1956MHz
	{ 0x07, 0xeb, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0491MHz, VCO=1964MHz
	{ 0x07, 0xed, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0493MHz, VCO=1972MHz
	{ 0x07, 0xef, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0495MHz, VCO=1980MHz
	{ 0x07, 0xf1, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0497MHz, VCO=1988MHz
	{ 0x07, 0xf3, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0499MHz, VCO=1996MHz
	{ 0x07, 0xf5, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0501MHz, VCO=2004MHz
	{ 0x07, 0xf7, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0503MHz, VCO=2012MHz
	{ 0x07, 0xf9, 0x40, 0x82, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0505MHz, VCO=2020MHz

	{ 0x06, 0xfe, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0508MHz, VCO=1016MHz

	{ 0x07, 0x00, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0512MHz, VCO=1024MHz
	{ 0x07, 0x02, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0516MHz, VCO=1032MHz
	{ 0x07, 0x04, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0520MHz, VCO=1040MHz
	{ 0x07, 0x06, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0524MHz, VCO=1048MHz
	{ 0x07, 0x08, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0528MHz, VCO=1056MHz
	{ 0x07, 0x0a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0532MHz, VCO=1064MHz
	{ 0x07, 0x0c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0536MHz, VCO=1072MHz
	{ 0x07, 0x0e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0540MHz, VCO=1080MHz
	{ 0x07, 0x10, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0544MHz, VCO=1088MHz
	{ 0x07, 0x12, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0548MHz, VCO=1096MHz
	{ 0x07, 0x14, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0552MHz, VCO=1104MHz
	{ 0x07, 0x16, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0556MHz, VCO=1112MHz
	{ 0x07, 0x18, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0560MHz, VCO=1120MHz
	{ 0x07, 0x1a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0564MHz, VCO=1128MHz
	{ 0x07, 0x1c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0568MHz, VCO=1136MHz
	{ 0x07, 0x1e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0572MHz, VCO=1144MHz
	{ 0x07, 0x20, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0576MHz, VCO=1152MHz
	{ 0x07, 0x22, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0580MHz, VCO=1160MHz
	{ 0x07, 0x24, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0584MHz, VCO=1168MHz
	{ 0x07, 0x26, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0588MHz, VCO=1176MHz
	{ 0x07, 0x28, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0592MHz, VCO=1184MHz
	{ 0x07, 0x2a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0596MHz, VCO=1192MHz
	{ 0x07, 0x2c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0600MHz, VCO=1200MHz
	{ 0x07, 0x2e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0604MHz, VCO=1208MHz
	{ 0x07, 0x30, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0608MHz, VCO=1216MHz
	{ 0x07, 0x32, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0612MHz, VCO=1224MHz
	{ 0x07, 0x34, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0616MHz, VCO=1232MHz
	{ 0x07, 0x36, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0620MHz, VCO=1240MHz
	{ 0x07, 0x38, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0624MHz, VCO=1248MHz
	{ 0x07, 0x3a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0628MHz, VCO=1256MHz
	{ 0x07, 0x3c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0632MHz, VCO=1264MHz
	{ 0x07, 0x3e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0636MHz, VCO=1272MHz
	{ 0x07, 0x40, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0640MHz, VCO=1280MHz
	{ 0x07, 0x42, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0644MHz, VCO=1288MHz
	{ 0x07, 0x44, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0648MHz, VCO=1296MHz
	{ 0x07, 0x46, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0652MHz, VCO=1304MHz
	{ 0x07, 0x48, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0656MHz, VCO=1312MHz
	{ 0x07, 0x4a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0660MHz, VCO=1320MHz
	{ 0x07, 0x4c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0664MHz, VCO=1328MHz
	{ 0x07, 0x4e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0668MHz, VCO=1336MHz
	{ 0x07, 0x50, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0672MHz, VCO=1344MHz
	{ 0x07, 0x52, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0676MHz, VCO=1352MHz
	{ 0x07, 0x54, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0680MHz, VCO=1360MHz
	{ 0x07, 0x56, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0684MHz, VCO=1368MHz
	{ 0x07, 0x58, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0688MHz, VCO=1376MHz
	{ 0x07, 0x5a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0692MHz, VCO=1384MHz
	{ 0x07, 0x5c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0696MHz, VCO=1392MHz
	{ 0x07, 0x5e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0700MHz, VCO=1400MHz
	{ 0x07, 0x60, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0704MHz, VCO=1408MHz
	{ 0x07, 0x62, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0708MHz, VCO=1416MHz
	{ 0x07, 0x64, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0712MHz, VCO=1424MHz
	{ 0x07, 0x66, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0716MHz, VCO=1432MHz
	{ 0x07, 0x68, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0720MHz, VCO=1440MHz
	{ 0x07, 0x6a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0724MHz, VCO=1448MHz
	{ 0x07, 0x6c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0728MHz, VCO=1456MHz
	{ 0x07, 0x6e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0732MHz, VCO=1464MHz
	{ 0x07, 0x70, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0736MHz, VCO=1472MHz
	{ 0x07, 0x72, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0740MHz, VCO=1480MHz
	{ 0x07, 0x74, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0744MHz, VCO=1488MHz
	{ 0x07, 0x76, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0748MHz, VCO=1496MHz
	{ 0x07, 0x78, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0752MHz, VCO=1504MHz
	{ 0x07, 0x7a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0756MHz, VCO=1512MHz
	{ 0x07, 0x7c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0760MHz, VCO=1520MHz
	{ 0x07, 0x7e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0764MHz, VCO=1528MHz
	{ 0x07, 0x80, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0768MHz, VCO=1536MHz
	{ 0x07, 0x82, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0772MHz, VCO=1544MHz
	{ 0x07, 0x84, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0776MHz, VCO=1552MHz
	{ 0x07, 0x86, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0780MHz, VCO=1560MHz
	{ 0x07, 0x88, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0784MHz, VCO=1568MHz
	{ 0x07, 0x8a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0788MHz, VCO=1576MHz
	{ 0x07, 0x8c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0792MHz, VCO=1584MHz
	{ 0x07, 0x8e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0796MHz, VCO=1592MHz
	{ 0x07, 0x90, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0800MHz, VCO=1600MHz
	{ 0x07, 0x92, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0804MHz, VCO=1608MHz
	{ 0x07, 0x94, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0808MHz, VCO=1616MHz
	{ 0x07, 0x96, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0812MHz, VCO=1624MHz
	{ 0x07, 0x98, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0816MHz, VCO=1632MHz
	{ 0x07, 0x9a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0820MHz, VCO=1640MHz
	{ 0x07, 0x9c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0824MHz, VCO=1648MHz
	{ 0x07, 0x9e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0828MHz, VCO=1656MHz
	{ 0x07, 0xa0, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0832MHz, VCO=1664MHz
	{ 0x07, 0xa2, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0836MHz, VCO=1672MHz
	{ 0x07, 0xa4, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0840MHz, VCO=1680MHz
	{ 0x07, 0xa6, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0844MHz, VCO=1688MHz
	{ 0x07, 0xa8, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0848MHz, VCO=1696MHz
	{ 0x07, 0xaa, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0852MHz, VCO=1704MHz
	{ 0x07, 0xac, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0856MHz, VCO=1712MHz
	{ 0x07, 0xae, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0860MHz, VCO=1720MHz
	{ 0x07, 0xb0, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0864MHz, VCO=1728MHz
	{ 0x07, 0xb2, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0868MHz, VCO=1736MHz
	{ 0x07, 0xb4, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0872MHz, VCO=1744MHz
	{ 0x07, 0xb6, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0876MHz, VCO=1752MHz
	{ 0x07, 0xb8, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0880MHz, VCO=1760MHz
	{ 0x07, 0xba, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0884MHz, VCO=1768MHz
	{ 0x07, 0xbc, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0888MHz, VCO=1776MHz
	{ 0x07, 0xbe, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0892MHz, VCO=1784MHz
	{ 0x07, 0xc0, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0896MHz, VCO=1792MHz
	{ 0x07, 0xc2, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0900MHz, VCO=1800MHz
	{ 0x07, 0xc4, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0904MHz, VCO=1808MHz
	{ 0x07, 0xc6, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0908MHz, VCO=1816MHz
	{ 0x07, 0xc8, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0912MHz, VCO=1824MHz
	{ 0x07, 0xca, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0916MHz, VCO=1832MHz
	{ 0x07, 0xcc, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0920MHz, VCO=1840MHz
	{ 0x07, 0xce, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0924MHz, VCO=1848MHz
	{ 0x07, 0xd0, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0928MHz, VCO=1856MHz
	{ 0x07, 0xd2, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0932MHz, VCO=1864MHz
	{ 0x07, 0xd4, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0936MHz, VCO=1872MHz
	{ 0x07, 0xd6, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0940MHz, VCO=1880MHz
	{ 0x07, 0xd8, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0944MHz, VCO=1888MHz
	{ 0x07, 0xda, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0948MHz, VCO=1896MHz
	{ 0x07, 0xdc, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0952MHz, VCO=1904MHz
	{ 0x07, 0xde, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0956MHz, VCO=1912MHz
	{ 0x07, 0xe0, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0960MHz, VCO=1920MHz
	{ 0x07, 0xe2, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0964MHz, VCO=1928MHz
	{ 0x07, 0xe4, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0968MHz, VCO=1936MHz
	{ 0x07, 0xe6, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0972MHz, VCO=1944MHz
	{ 0x07, 0xe8, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0976MHz, VCO=1952MHz
	{ 0x07, 0xea, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0980MHz, VCO=1960MHz
	{ 0x07, 0xec, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0984MHz, VCO=1968MHz
	{ 0x07, 0xee, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0988MHz, VCO=1976MHz
	{ 0x07, 0xf0, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0992MHz, VCO=1984MHz
	{ 0x07, 0xf2, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=0996MHz, VCO=1992MHz
	{ 0x07, 0xf4, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1000MHz, VCO=2000MHz
	{ 0x07, 0xf6, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1004MHz, VCO=2008MHz
	{ 0x07, 0xf8, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1008MHz, VCO=2016MHz
	{ 0x07, 0xfa, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1012MHz, VCO=2024MHz
	{ 0x07, 0xfc, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1016MHz, VCO=2032MHz
	{ 0x07, 0xfe, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1020MHz, VCO=2040MHz

	{ 0x05, 0x56, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1026MHz, VCO=2052MHz
	{ 0x05, 0x58, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1032MHz, VCO=2064MHz
	{ 0x05, 0x5a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1038MHz, VCO=2076MHz
	{ 0x05, 0x5c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1044MHz, VCO=2088MHz
	{ 0x05, 0x5e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1050MHz, VCO=2100MHz
	{ 0x05, 0x60, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1056MHz, VCO=2112MHz
	{ 0x05, 0x62, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1062MHz, VCO=2124MHz
	{ 0x05, 0x64, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1068MHz, VCO=2136MHz
	{ 0x05, 0x66, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1074MHz, VCO=2148MHz
	{ 0x05, 0x68, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1080MHz, VCO=2160MHz
	{ 0x05, 0x6a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1086MHz, VCO=2172MHz
	{ 0x05, 0x6c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1092MHz, VCO=2184MHz
	{ 0x05, 0x6e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1098MHz, VCO=2196MHz
	{ 0x05, 0x70, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1104MHz, VCO=2208MHz
	{ 0x05, 0x72, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1110MHz, VCO=2220MHz
	{ 0x05, 0x74, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1116MHz, VCO=2232MHz
	{ 0x05, 0x76, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1122MHz, VCO=2244MHz
	{ 0x05, 0x78, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1128MHz, VCO=2256MHz
	{ 0x05, 0x7a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1134MHz, VCO=2268MHz
	{ 0x05, 0x7c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1140MHz, VCO=2280MHz
	{ 0x05, 0x7e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1146MHz, VCO=2292MHz
	{ 0x05, 0x80, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1152MHz, VCO=2304MHz
	{ 0x05, 0x82, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1158MHz, VCO=2316MHz
	{ 0x05, 0x84, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1164MHz, VCO=2328MHz
	{ 0x05, 0x86, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1170MHz, VCO=2340MHz
	{ 0x05, 0x88, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1176MHz, VCO=2352MHz
	{ 0x05, 0x8a, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1182MHz, VCO=2364MHz
	{ 0x05, 0x8c, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1188MHz, VCO=2376MHz
	{ 0x05, 0x8e, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1194MHz, VCO=2388MHz
	{ 0x05, 0x90, 0x40, 0x42, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x24, 0x00, 0x00 },//PLL=1200MHz, VCO=2400MHz
};

static bool set_pll_config(struct T3_chain *t3, int idxpll)
{
	uint8_t temp_reg[REG_LENGTH];
	int i;
	uint32_t pll_fbdiv, pll_prediv, pll_postdiv, postdiv;
	uint32_t f_vco, f_pll;


	for(i = 0; i < 380; i++)
	{
		memcpy(temp_reg, default_reg[i], REG_LENGTH-2);
		applog(LOG_WARNING,
	       "{ 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x, 0x%02x },",
	       temp_reg[0], temp_reg[1], temp_reg[2],
	       temp_reg[3], temp_reg[4], temp_reg[5],
	       temp_reg[6], temp_reg[7], temp_reg[8],
	       temp_reg[9], temp_reg[10], temp_reg[11]);

	    if (!cmd_WRITE_REG(t3, ADDR_BROADCAST, temp_reg))
		{
			pll_fbdiv = ((((uint32_t)temp_reg[0]) << 8) & 0x00000100) | (((uint32_t)temp_reg[1]) & 0x000000ff);
			pll_prediv = (((uint32_t)temp_reg[0]) >> 1) & 0x0000001f;
			pll_postdiv = (((uint32_t)temp_reg[3]) >> 6) & 0x00000003;
			postdiv = (1 << pll_postdiv);

			f_vco = 12 * pll_fbdiv / pll_prediv;
			f_pll = f_vco / postdiv;
			printf("pll_fbdiv: %d, pll_prediv: %d, pll_postdiv: %d\n", pll_fbdiv, pll_prediv, pll_postdiv);			
			applog(LOG_ERR, "set PLL %d MHz fail vco %d MHz", f_pll, f_vco);
			return false;
		}
		
		cgsleep_us(100000);
	}

	pll_fbdiv = ((((uint32_t)temp_reg[0]) << 8) & 0x00000100) | (((uint32_t)temp_reg[1]) & 0x000000ff);
	pll_prediv = (((uint32_t)temp_reg[0]) >> 1) & 0x0000001f;
	pll_postdiv = (((uint32_t)temp_reg[3]) >> 6) & 0x00000003;
	postdiv = (1 << pll_postdiv);

	f_vco = 12 * pll_fbdiv / pll_prediv;
	f_pll = f_vco / postdiv;

	applog(LOG_WARNING, "set PLL %d MHz success vco %d MHz", f_pll, f_vco);

	int from = 0;
	int to = t3->num_chips;

	for (i = from; i < to; i++) {
		int cid = i + 1;
		if (!check_chip_pll_lock(t3, cid, temp_reg)) {
			applog(LOG_ERR, "%d: chip %d failed PLL lock",
			       t3->chain_id, cid);
			//return false;
		}
	}
	return true;
}
static bool check_chip(struct T3_chain *t3, int i)
{
	int chip_id = i + 1;
	int cid = t3->chain_id;
	if (!cmd_READ_REG(t3, chip_id)) {
		applog(LOG_WARNING, "%d: Failed to read register for "
		       "chip %d -> disabling", cid, chip_id);
		t3->chips[i].num_cores = 0;
		t3->chips[i].disabled = 1;
		return false;;
	}
	t3->chips[i].num_cores = t3->spi_rx[13];
	t3->num_cores += t3->chips[i].num_cores;
	applog(LOG_WARNING, "%d: Found chip %d with %d active cores",
	       cid, chip_id, t3->chips[i].num_cores);
	return true;
}

/********** disable / re-enable related section (temporary for testing) */
static int get_current_ms(void)
{
	cgtimer_t ct;
	cgtimer_time(&ct);
	return cgtimer_to_ms(&ct);
}

static bool is_chip_disabled(struct T3_chain *t3, uint8_t chip_id)
{
	struct T3_chip *chip = &t3->chips[chip_id - 1];
	return chip->disabled || chip->cooldown_begin != 0;
}


int chain_t3_detect(struct T3_chain *t3, int idxpll)
{
	int i;
	int cid = t3->chain_id;
	int spi_clk_khz = 100000;
//	set_spi_speed(t3->spi_ctx, spi_clk_khz);

	if(!cmd_RESET_BCAST(t3, 0x00))
		applog(LOG_WARNING, "cmd_RESET_BCAST fail");

	cgsleep_us(1000);
	t3->num_chips = chain_chips(t3);
	if (t3->num_chips == 0)
		goto failure;

	applog(LOG_WARNING, "spidev%d.%d %d: Found %d T3 chips",
   		t3->spi_ctx->config.bus, t3->spi_ctx->config.cs_line,
   		t3->chain_id, t3->num_chips);

	cgsleep_us(10000);
	if (!set_pll_config(t3, idxpll))
		goto failure;

	spi_clk_khz = 2000000;
//	set_spi_speed(t3->spi_ctx, spi_clk_khz);
	cgsleep_us(1000);

	t3->num_active_chips = t3->num_chips;
	t3->chips = calloc(t3->num_active_chips, sizeof(struct T3_chip));
	assert(t3->chips != NULL);

	cgsleep_us(10000);
	if(!cmd_BIST_COLLECT_BCAST(t3))
		goto failure;
	applog(LOG_WARNING, "collect core success");

	cgsleep_us(1000);
	if (!cmd_BIST_FIX_BCAST(t3))
		goto failure;
		
	applog(LOG_WARNING, "bist fix success");
		
	for (i = 0; i < t3->num_active_chips; i++)
	{
		check_chip(t3, i);
	}
	return t3->num_chips;
failure:
	return -1;
}

/* check and disable chip, remember time */
static void disable_chip(struct T3_chain *t3, uint8_t chip_id)
{
	flush_spi(t3);
	struct T3_chip *chip = &t3->chips[chip_id - 1];
	int cid = t3->chain_id;
	if (is_chip_disabled(t3, chip_id)) {
		applog(LOG_WARNING, "%d: chip %d already disabled",
		       cid, chip_id);
		return;
	}
	applog(LOG_WARNING, "%d: temporary disabling chip %d", cid, chip_id);
	chip->cooldown_begin = get_current_ms();
}

/* check if disabled chips can be re-enabled */
void check_disabled_chips(struct T3_chain *t3, int pllnum)
{
	int i;
	int cid = t3->chain_id;
	uint8_t reg[REG_LENGTH];
	struct spi_ctx *ctx = t3->spi_ctx;

	for (i = 0; i < t3->num_active_chips; i++) 
	{
		int chip_id = i + 1;
		struct T3_chip *chip = &t3->chips[i];
		if (!is_chip_disabled(t3, chip_id))
			continue;
		/* do not re-enable fully disabled chips */
		if (chip->disabled)
			continue;
		if (chip->cooldown_begin + COOLDOWN_MS > get_current_ms())
			continue;

		//if the core in chain least than 432, reinit this chain
		if(t3->num_cores <= LEAST_CORE_ONE_CHAIN && chip->fail_reset < RESET_CHAIN_CNT)
		{

#if 0
			chip->fail_reset++;
			asic_gpio_write(ctx->reset, 0);
			cgsleep_us(500000);
			asic_gpio_write(ctx->reset, 1); 
#else
			chip->fail_reset++;
			system("echo 1 > /sys/class/gpio/gpio114/value");
			cgsleep_us(500000);
			system("echo 0 > /sys/class/gpio/gpio114/value");
#endif
			t3->num_chips = chain_t3_detect(t3, pllnum);
		
		}
		
		if (!cmd_READ_REG(t3, chip_id)) 
		{
			chip->fail_count++;
			applog(LOG_WARNING, "%d: chip %d not yet working - %d",
				   cid, chip_id, chip->fail_count);
			if (chip->fail_count > DISABLE_CHIP_FAIL_THRESHOLD) 
			{
				applog(LOG_WARNING, "%d: completely disabling chip %d at %d",
					   cid, chip_id, chip->fail_count);
				chip->disabled = true;
				t3->num_cores -= chip->num_cores;	
				
				continue;
			}
			/* restart cooldown period */
			chip->cooldown_begin = get_current_ms();
			continue;
		}
		applog(LOG_WARNING, "%d: chip %d is working again", cid, chip_id);
		chip->cooldown_begin = 0;
		chip->fail_count = 0;
		chip->fail_reset = 0;
	}
}

/********** job creation and result evaluation */
uint32_t get_diff(double diff)
{
	uint32_t n_bits;
	int shift = 29;
	double f = (double) 0x0000ffff / diff;
	while (f < (double) 0x00008000) {
		shift--;
		f *= 256.0;
	}
	while (f >= (double) 0x00800000) {
		shift++;
		f /= 256.0;
	}
	n_bits = (int) f + (shift << 24);
	return n_bits;
}

static uint8_t *create_job(uint8_t chip_id, uint8_t job_id, struct work *work)
{
	unsigned char *wdata = work->data;
	uint8_t data[128];
	double sdiff = work->sdiff;
	uint8_t tmp_buf[JOB_LENGTH];
	uint16_t crc;
	uint8_t i;

	memset(data, 0, 128);

	for(int j=0; j<20; j++)
	{
		data[j*4 + 3] = work->data[j*4 + 0];
		data[j*4 + 2] = work->data[j*4 + 1];
		data[j*4 + 1] = work->data[j*4 + 2];
		data[j*4 + 0] = work->data[j*4 + 3];
	}
	wdata = data;

	static uint8_t job[JOB_LENGTH] = {
		/* command */
		0x00, 0x00,
		/* wdata 75 to 0 */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		/* start nonce */
		0x00, 0x00, 0x00, 0x00,
		/* difficulty */
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/* end nonce */
		0x00, 0x00, 0x00, 0x00,
		/* crc data */
		0x00, 0x00
	};

	uint8_t diffIdx;
	uint8_t data75to0[76];
	uint8_t startnonce[4] = {0x00, 0x00, 0x00, 0x00};
	uint8_t diff[8] = {0x1e, 0x00, 0x00, 0x00, 0x00, 0x03, 0xff, 0xff};
	uint8_t endnonce[4] = {0x00, 0x40, 0x00, 0x00}; // 10s

	memcpy(data75to0, wdata, 76);
	printf("dongfupang %s() %d  work->sdiff %d\n", __func__, __LINE__,  (int)sdiff);

	if(sdiff > 63.0)
		memcpy(diff, difficult_Tbl[7], 8);
	else if(sdiff > 31.0)
			memcpy(diff, difficult_Tbl[6], 8);
	else if(sdiff > 15.0)
			memcpy(diff, difficult_Tbl[5], 8);
	else if(sdiff > 7.0)
			memcpy(diff, difficult_Tbl[4], 8);
	else if(sdiff > 3.0)
				memcpy(diff, difficult_Tbl[3], 8);
	else if(sdiff == 2.0)
		memcpy(diff, difficult_Tbl[2], 8);
	else if(sdiff == 1.0)
		memcpy(diff, difficult_Tbl[1], 8);
	else if(sdiff < 1.0)
		memcpy(diff, difficult_Tbl[0], 8);

	startnonce[0]=0x00;
	startnonce[1]=0x00;
	startnonce[2]=0x00;
	startnonce[3]=0x00;

	endnonce[0]=0xff;
	endnonce[1]=0xff;
	endnonce[2]=0xff;
	endnonce[3]=0xff;

	//rev(data75to0, 76);
	rev(startnonce, 4);
	rev(diff, 8);
	rev(endnonce, 4);

	job[0] = (job_id << 4) | T3_WRITE_JOB;
	job[1] = chip_id;
	memcpy(job+2,			data75to0,	76);
	memcpy(job+2+76,		startnonce, 4);
	memcpy(job+2+76+4,		diff, 8);
	memcpy(job+2+76+4+8,	endnonce, 4);

	/* crc */
	memset(tmp_buf, 0, sizeof(tmp_buf));
	for(i = 0; i < 47; i++)
	{
		tmp_buf[(2 * i) + 1] = job[(2 * i) + 0];
		tmp_buf[(2 * i) + 0] = job[(2 * i) + 1];
	}
	crc = CRC16_2(tmp_buf, 94);
	job[94] = (uint8_t)((crc >> 8) & 0xff);
	job[95] = (uint8_t)((crc >> 0) & 0xff);

	return job;
}

/* set work for given chip, returns true if a nonce range was finished */
static bool set_work(struct T3_chain *t3, uint8_t chip_id, struct work *work,
		     uint8_t queue_states)
{
	int cid = t3->chain_id;
	struct T3_chip *chip = &t3->chips[chip_id - 1];
	bool retval = false;

	int job_id = chip->last_queued_id + 1;

	//applog(LOG_INFO, "%d: queuing chip %d with job_id %d, state=0x%02x",
	       //cid, chip_id, job_id, queue_states);
	if (job_id == (queue_states & 0x0f) || job_id == (queue_states >> 4))
		applog(LOG_WARNING, "%d: job overlap: %d, 0x%02x",
		       cid, job_id, queue_states);

	if (chip->work[chip->last_queued_id] != NULL) {
		work_completed(t3->cgpu, chip->work[chip->last_queued_id]);
		chip->work[chip->last_queued_id] = NULL;
		retval = true;
	}
	uint8_t *jobdata = create_job(chip_id, job_id, work);
	if (!cmd_WRITE_JOB(t3, chip_id, jobdata)) {
		/* give back work */
		work_completed(t3->cgpu, work);
		applog(LOG_ERR, "%d: failed to set work for chip %d.%d",
		       cid, chip_id, job_id);
		disable_chip(t3, chip_id);
	} else {
		chip->work[chip->last_queued_id] = work;
		chip->last_queued_id++;
		chip->last_queued_id &= 3;
	}
	return retval;
}

static bool get_nonce(struct T3_chain *t3, uint8_t *nonce,
		      uint8_t *chip, uint8_t *job_id)
{
	uint8_t *ret = cmd_READ_RESULT_BCAST(t3);
	if (ret == NULL)
		return false;

	*job_id = ret[0] >> 4;
	*chip = ret[1];
	memcpy(nonce, ret + 2, 4);
	return true;
}

/* reset input work queues in chip chain */
static bool abort_work(struct T3_chain *t3)
{
	/* drop jobs already queued and result queue: reset strategy (0xeded & 0xf7f7) */
	//applog(LOG_INFO,"Start to reset ");
//return cmd_RESET_BCAST(t3, 0xe5);
	return true;
}

void exit_t3_chain(struct T3_chain *t3)
{
	if (t3 == NULL)
		return;
	free(t3->chips);
	t3->chips = NULL;
	t3->spi_ctx = NULL;
	free(t3);
}

void exit_T3_chain(struct T3_chain *t3)
{
	if (t3 == NULL)
		return;
	free(t3->chips);
	t3->chips = NULL;
	t3->spi_ctx = NULL;
	free(t3);
}

bool inno_cmd_resetjob(struct T3_chain *t3, uint8_t chip_id)
{
	//printf("send command job [reset] \n");

	if(!cmd_RESET_IDUAL(t3, chip_id))
	{
		applog(LOG_WARNING, "cmd_RESET_BCAST fail !");
	}

	if(cmd_CHECK_BUSY(t3, chip_id) != WORK_FREE)
	{
		return false;
	}

	return true;
	
}

static void chain_t3_hw_enable(int num_chain)
{
	/*
	 *chain 1
	 *GPIO_RST1(start pin) -> GPMC_A5(gpio1_21) -> gpio53
	 *CTL0_IO0 (reset pin) -> MCASP0_ACLKR(gpio3_18) -> gpio114
	 */
	applog(LOG_DEBUG, "T3 enable chain RST1");
	int ret;

	switch(num_chain){
		case 0:
			//GPIO3_19 host pin8
			ret = access("/sys/class/gpio/gpio115", F_OK); //power enable
			if(ret == -1)//file not exist
			{
				system("echo 115 > /sys/class/gpio/export");
				system("echo out > /sys/class/gpio/gpio115/direction");
				system("echo 0 > /sys/class/gpio/gpio115/value");
			}
			//GPMC_A5 gpio1_21 host pin14
			ret = access("/sys/class/gpio/gpio53", F_OK); //start
			if(ret == -1)//file not exist
			{
				system("echo 53 > /sys/class/gpio/export");
				system("echo out > /sys/class/gpio/gpio53/direction");
				system("echo 1 > /sys/class/gpio/gpio53/value");
			}
			//GPIO3_18 host pin6
			ret = access("/sys/class/gpio/gpio114", F_OK); //reset
			if(ret == -1)//file not exist
			{
				system("echo 114 > /sys/class/gpio/export");
				system("echo out > /sys/class/gpio/gpio114/direction");
				system("echo 1 > /sys/class/gpio/gpio114/value");
			}
			cgsleep_us(1000 * 500);
			system("echo 1 > /sys/class/gpio/gpio115/value");

			//start pin and reset pin set low level

			//after power on it assert reset pin and wait 500ms	
			system("echo 0 > /sys/class/gpio/gpio114/value");
			cgsleep_us(1000 * 500);

			//assert start pin and wait 500ms
			system("echo 0 > /sys/class/gpio/gpio53/value");

			cgsleep_us(1000 * 500);

			break;
		case 1:
			break;
		case 2:
			break;
		default:;
	}
}


static void chain_t2_hw_enable(int num_chain)
{
	/*
	 *chain 1
	 *GPIO_RST1(start pin) -> GPMC_A5(gpio1_21) -> gpio53
	 *CTL0_IO0 (reset pin) -> MCASP0_ACLKR(gpio3_18) -> gpio114
	 */
	int ret;
	applog(LOG_DEBUG, "T3 enable chain RST1");

	switch(num_chain){
		case 0:
			//GPIO3_19 host pin8
			ret = access("/sys/class/gpio/gpio115", F_OK); //power enable
			if(ret == -1)//file not exist
			{
				system("echo 115 > /sys/class/gpio/export");
				system("echo out > /sys/class/gpio/gpio115/direction");
				system("echo 0 > /sys/class/gpio/gpio115/value");
			}
			//GPMC_A5 gpio1_21 host pin14
			ret = access("/sys/class/gpio/gpio53", F_OK); //start
			if(ret == -1)//file not exist
			{
				system("echo 53 > /sys/class/gpio/export");
				system("echo out > /sys/class/gpio/gpio53/direction");
				system("echo 1 > /sys/class/gpio/gpio53/value");
			}
			//GPIO3_18 host pin6
			ret = access("/sys/class/gpio/gpio114", F_OK); //reset
			if(ret == -1)//file not exist
			{
				system("echo 114 > /sys/class/gpio/export");
				system("echo out > /sys/class/gpio/gpio114/direction");
				system("echo 1 > /sys/class/gpio/gpio114/value");
			}

			//start pin and reset pin set low level

			//after power on it assert reset pin and wait 500ms
			system("echo 1 > /sys/class/gpio/gpio115/value");
			system("echo 0 > /sys/class/gpio/gpio53/value");
			system("echo 0 > /sys/class/gpio/gpio114/value");
			cgsleep_us(1000 * 500);

			//assert start pin and wait 500ms
			system("echo 1 > /sys/class/gpio/gpio114/value");
			cgsleep_us(1000 * 500);
			system("echo 0 > /sys/class/gpio/gpio114/value");
			cgsleep_us(1000 * 500);
			break;
		case 1:
			//GPMC_AD11 gpio0_27  host pin8
			ret = access("/sys/class/gpio/gpio27", F_OK); //power enable
			if(ret == -1)//file not exist
			{
				system("echo 27 > /sys/class/gpio/export");
				system("echo out > /sys/class/gpio/gpio27/direction");
				system("echo 0 > /sys/class/gpio/gpio27/value");
			}
			//GPMC_A6 gpio1_22 host pin14
			ret = access("/sys/class/gpio/gpio54", F_OK); //start
			if(ret == -1)//file not exist
			{
				system("echo 54 > /sys/class/gpio/export");
				system("echo out > /sys/class/gpio/gpio54/direction");
				system("echo 1 > /sys/class/gpio/gpio54/value");
			}
			//GPMC_AD10 gpio0_26  host pin6
			ret = access("/sys/class/gpio/gpio45", F_OK); //reset
			if(ret == -1)//file not exist
			{
				system("echo 45 > /sys/class/gpio/export");
				system("echo out > /sys/class/gpio/gpio45/direction");
				system("echo 1 > /sys/class/gpio/gpio45/value");
			}

			//power on and reset pin and wait 500ms
			system("echo 1 > /sys/class/gpio/gpio27/value");
			system("echo 0 > /sys/class/gpio/gpio54/value");
			system("echo 0 > /sys/class/gpio/gpio45/value");
			cgsleep_us(1000 * 500);

			//assert start pin and wait 500ms
			system("echo 1 > /sys/class/gpio/gpio45/value");
			cgsleep_us(1000 * 500);
			system("echo 0 > /sys/class/gpio/gpio45/value");
			cgsleep_us(1000 * 500);
			break;
		case 2:
			break;
		default:;
	}
}


struct T3_chain *init_T3_chain(struct spi_ctx *ctx, int chain_id)
{
	int i;
	struct T3_chain *t3 = malloc(sizeof(*t3));
	assert(t3 != NULL);

	
	memset(t3, 0, sizeof(*t3));
	t3->spi_ctx = ctx;
	t3->chain_id = chain_id;

	applog(LOG_INFO,"chain_id:%d", chain_id);
	switch(chain_id){
		case 0:t3->num_chips = chain_t3_detect(t3, A1Pll1);break;
		case 1:t3->num_chips = chain_t3_detect(t3, A1Pll2);break;
		case 2:t3->num_chips = chain_t3_detect(t3, A1Pll3);break;
		case 3:t3->num_chips = chain_t3_detect(t3, A1Pll4);break;
		case 4:t3->num_chips = chain_t3_detect(t3, A1Pll5);break;
		case 5:t3->num_chips = chain_t3_detect(t3, A1Pll6);break;
		default:;
	}
	cgsleep_us(10000);
	
	if (t3->num_chips == 0)
		goto failure;

	applog(LOG_WARNING, "spidev%d.%d: %d: Found %d T3 chips",
	       t3->spi_ctx->config.bus, t3->spi_ctx->config.cs_line,
	       t3->chain_id, t3->num_chips);
	
	t3->num_active_chips = t3->num_chips;

	t3->chips = calloc(t3->num_active_chips, sizeof(struct T3_chip));
	assert (t3->chips != NULL);


	applog(LOG_WARNING, "%d: found %d chips with total %d active cores",
	       t3->chain_id, t3->num_active_chips, t3->num_cores);

	mutex_init(&t3->lock);
	INIT_LIST_HEAD(&t3->active_wq.head);

	return t3;

failure:
	exit_T3_chain(t3);
	return NULL;
}

static bool detect_T3_chain()
{
	int i;
	
	applog(LOG_WARNING, "T3: checking T3 chain");

	for(i = 0; i < ASIC_CHAIN_NUM; i++)
	{
		cfg[i] = default_spi_config;
		cfg[i].bus     = i + 1;
		cfg[i].cs_line = 0;
		cfg[i].mode = SPI_MODE_1;

		cfg[i].speed = DEFAULT_SPI_SPEED;

		spi[i] = spi_init(&cfg[i]);
		if (spi == NULL)
		{
			applog(LOG_ERR, "spi init fail");
			return false;
		}
	}

	for(i = 0; i < ASIC_CHAIN_NUM; i++)
	{
		// chains power on
		chain_t3_hw_enable( i );
	}

	for(i = 0; i < ASIC_CHAIN_NUM; i++)
	{
		chain[i] = init_T3_chain(spi[i], i);
		if (chain[i] == NULL)
		{
			applog(LOG_ERR, "init t3 chain fail");
			return false;
		}

		struct cgpu_info *cgpu = malloc(sizeof(*cgpu));
		assert(cgpu != NULL);
	
		memset(cgpu, 0, sizeof(*cgpu));
		cgpu->drv = &bitmineA1_drv;
		cgpu->name = "BitmineA1.SingleChainn";
		cgpu->threads = 1;

		cgpu->device_data = chain[i];

		chain[i]->cgpu = cgpu;
		add_cgpu(cgpu);

		applog(LOG_WARNING, "Detected the %d T3 chain with %d chips / %d cores",
		       i, chain[i]->num_active_chips, chain[i]->num_cores);
	}

	return true;
}

static void chain_hw_dis(void)
{
}

/* Probe SPI channel and register chip chain */
void T3_detect(bool hotplug)
{
	/* no hotplug support for SPI */
	if (hotplug)
		return;

	applog(LOG_DEBUG, "T3 detect");

	/* detect and register supported products */
	if (detect_T3_chain())
		return;

    int i = 0;
	/* release SPI context if no T3 products found */
	for(i = 0; i < ASIC_CHAIN_NUM; i++)
	{
		spi_exit(spi[i]);
	}

}

#define TEMP_UPDATE_INT_MS	2000
static int64_t T3_scanwork(	struct thr_info *thr)
{
	int i;
	int32_t A1Pll = 1000;
	struct cgpu_info *cgpu = thr->cgpu;
	struct T3_chain *t3 = cgpu->device_data;
	int32_t nonce_ranges_processed = 0;

	if (t3->num_cores == 0) {
		cgpu->deven = DEV_DISABLED;
		return 0;
	}

	//board_selector->select(t3->chain_id);
	//applog(LOG_DEBUG, "T3 running scanwork");

	uint32_t nonce;
	uint8_t chip_id;
	uint8_t job_id;
	bool work_updated = false;
	uint32_t k, *work_nonce=NULL;
	unsigned char pworkdata[128]= {0},  hash1[32]= {0};
    unsigned int endiandata[32]= {0};

    struct work gwork = {
	    .data = {
			0x20, 0x00, 0x00, 0x00,
			0x1b, 0x7d, 0x2f, 0x24,
			0x2d, 0xdd, 0x05, 0x56,
			0x7b, 0xdc, 0x29, 0x22,
			0x25, 0x52, 0x7c, 0x0b,
			0x72, 0xbb, 0x12, 0xc7,
			0x42, 0xf8, 0x7f, 0xed,
			0x00, 0x00, 0x00, 0x1b,
			0x00, 0x00, 0x00, 0x00,
			0x24, 0x62, 0x39, 0xb5,
			0xbf, 0x5d, 0x65, 0x9b,
			0xad, 0x59, 0x8c, 0xa1,
			0x2c, 0x9a, 0x2c, 0xae,
			0xc8, 0x35, 0xb5, 0xe4,
			0x8b, 0x83, 0x93, 0x6d,
			0x40, 0xa9, 0x92, 0x84,
			0xd1, 0x77, 0x47, 0x44,
			0x5a, 0x5d, 0xcf, 0x88,
			0x19, 0x3b, 0xec, 0x0e,
			0x00, 0x00, 0x00, 0x00,
		},
		.target = {
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x0f, 0xff,
			0x0f, 0x00, 0x00, 0x00,
		},
	};


	mutex_lock(&t3->lock);

	if (t3->last_temp_time + TEMP_UPDATE_INT_MS < get_current_ms())
	{
		//t3->temp = board_selector->get_temp(0);
		t3->last_temp_time = get_current_ms();
	}
	int cid = t3->chain_id; 
	uint32_t *target32;

	/* poll queued results */
	while (true)
	{
		if (!get_nonce(t3, (uint8_t*)&nonce, &chip_id, &job_id))
			break;

		//nonce = bswap_32(nonce);   //modify for A4
		printf("dongfupang %s() %d nonce = %08x\n", __func__, __LINE__, nonce);
		work_updated = true;
		if (chip_id < 1 || chip_id > t3->num_active_chips) 
		{
			applog(LOG_WARNING, "%d: wrong chip_id %d", cid, chip_id);
			continue;
		}
		if (job_id < 1 && job_id > 15) 
		{
			applog(LOG_WARNING, "%d: chip %d: result has wrong ""job_id %d", cid, chip_id, job_id);
			flush_spi(t3);
			continue;
		}

		struct T3_chip *chip = &t3->chips[chip_id - 1];
		struct work *work = chip->work[job_id - 1];
		if (work == NULL) 
		{
			/* already been flushed => stale */
			applog(LOG_WARNING, "%d: chip %d: stale nonce 0x%08x", cid, chip_id, nonce);
			chip->stales++;
			continue;
		}
		target32 = (uint32_t *)(work->target);
		const uint32_t Htarg = le32toh(target32[7]);
		work_nonce = (uint32_t *)(work->data + 64 + 12);
		*work_nonce = nonce;
		memcpy(pworkdata, work->data, 80);

        for (k=0; k < 20; k++)
        {
            endiandata[k] = ((uint32_t*)pworkdata)[k];
            endiandata[k] = Swap32(endiandata[k]);
            //applog(LOG_DEBUG,"%s: endiandata[%d] = 0x%08x", __FUNCTION__, k, endiandata[k]);
        }

        Xhash(hash1, endiandata);
        memcpy(work->hash, hash1, 32);
		printf("dongfupang %s() %d *((uint32_t *)(work->hash) + 7) = %08x\n", __func__, __LINE__, *((uint32_t *)(work->hash) + 7));
		printf("dongfupang %s() %d *((uint32_t *)(work->hash) + 6) = %08x\n", __func__, __LINE__, *((uint32_t *)(work->hash) + 6));
		printf("dongfupang %s() %d target32[7] = %08x\n", __func__, __LINE__, le32toh(target32[7]));
		printf("dongfupang %s() %d target32[6] = %08x\n", __func__, __LINE__, le32toh(target32[6]));
		if(*((uint32_t *)(work->hash) + 7) <= Htarg)
		{
			update_work_stats(thr, work);
			if (fulltest(hash1, work->target))
			{
				printf("*******************************\n");
				printf("dongfupang %s() %d nonce = %08x\n", __func__, __LINE__, nonce);
				printf("*******************************\n");
				submit_nonce_direct(thr,work, nonce);
			}
		} else {
			applog(LOG_WARNING, "%d: chip %d: invalid nonce 0x%08x", cid, chip_id, nonce);
			chip->hw_errors++;
			/* add a penalty of a full nonce range on HW errors */
			nonce_ranges_processed--;
			continue;
		}
		applog(LOG_INFO, "YEAH: %d: chip %d / job_id %d: nonce 0x%08x", cid, chip_id, job_id, nonce);
		chip->nonces_found++;
	}

	uint8_t reg[REG_LENGTH];
	/* check for completed works */
	if(t3->work_start_delay > 0)
	{
		applog(LOG_INFO, "wait for pll stable");
		t3->work_start_delay--;
	}
	else
	{
		for (i = t3->num_active_chips; i > 0; i--) 
		{
			uint8_t c = i;
			if (is_chip_disabled(t3, c))
				continue;
			if (!cmd_READ_REG(t3, c)) 
			{
				disable_chip(t3, c);
				continue;
			}
            else
            {
            	//hexdump("send433: RX", t3->spi_rx, 18);
                /* update temp database */
                uint32_t temp = 0;
                float    temp_f = 0.0f;

                temp = 0x000003ff & ((reg[7] << 8) | reg[8]);
                //inno_fan_temp_add(&s_fan_ctrl, cid, temp, false);
            }

			uint8_t qstate = t3->spi_rx[11] & 0x01;
			uint8_t qbuff = 0;
			struct work *work;
			struct T3_chip *chip = &t3->chips[i - 1];
			switch(qstate) 
			{
			
			case 1:
				//applog(LOG_INFO, "chip %d busy now", i);
				break;
				/* fall through */
			case 0:
				work_updated = true;

				work = wq_dequeue(&t3->active_wq);
				if (work == NULL) 
				{
					applog(LOG_INFO, "%d: chip %d: work underflow", cid, c);
					break;
				}
				if (set_work(t3, c, work, qbuff)) 
				{
					chip->nonce_ranges_done++;
					nonce_ranges_processed++;
					applog(LOG_INFO, "set work success %d, nonces processed %d", cid, nonce_ranges_processed);
				}
				
				//applog(LOG_INFO, "%d: chip %d: job done: %d/%d/%d/%d",
				//       cid, c,
				//       chip->nonce_ranges_done, chip->nonces_found,
				//       chip->hw_errors, chip->stales);
				break;
			}
		} 
        //inno_fan_speed_update(&s_fan_ctrl, cid);
	}

	switch(cid){
		case 0:check_disabled_chips(t3, A1Pll1);;break;
		case 1:check_disabled_chips(t3, A1Pll2);;break;
		case 2:check_disabled_chips(t3, A1Pll3);;break;
		case 3:check_disabled_chips(t3, A1Pll4);;break;
		case 4:check_disabled_chips(t3, A1Pll5);;break;
		case 5:check_disabled_chips(t3, A1Pll6);;break;
		default:;
	}

	mutex_unlock(&t3->lock);

	//board_selector->release();

	if (nonce_ranges_processed < 0)
	{
		applog(LOG_INFO, "nonce_ranges_processed less than 0");
		nonce_ranges_processed = 0;
	}

	if (nonce_ranges_processed != 0) 
	{
		applog(LOG_INFO, "%d, nonces processed %d", cid, nonce_ranges_processed);
	}
	/* in case of no progress, prevent busy looping */
	//if (!work_updated)
	//	cgsleep_ms(40);

	cgtime(&t3->tvScryptCurr);
	timersub(&t3->tvScryptCurr, &t3->tvScryptLast, &t3->tvScryptDiff);
	cgtime(&t3->tvScryptLast);


	switch(cgpu->device_id){
		case 0:A1Pll = T3_REG_TO_CLOCK(A1Pll1);break;
		case 1:A1Pll = T3_REG_TO_CLOCK(A1Pll2);break;
		case 2:A1Pll = T3_REG_TO_CLOCK(A1Pll3);break;
		case 3:A1Pll = T3_REG_TO_CLOCK(A1Pll4);break;
		case 4:A1Pll = T3_REG_TO_CLOCK(A1Pll5);break;
		case 5:A1Pll = T3_REG_TO_CLOCK(A1Pll6);break;
		default:;
	}


	return (int64_t)(2011173.18 * A1Pll / 1000 * (t3->num_cores/9.0) * (t3->tvScryptDiff.tv_usec / 1000000.0));

}


/* queue two work items per chip in chain */
static bool T3_queue_full(struct cgpu_info *cgpu)
{
	struct T3_chain *t3 = cgpu->device_data;
	int queue_full = false;

	mutex_lock(&t3->lock);
	//applog(LOG_DEBUG, "%d, T3 running queue_full: %d/%d",
	       //t3->chain_id, t3->active_wq.num_elems, t3->num_active_chips);

	if (t3->active_wq.num_elems >= t3->num_active_chips * 2)
		queue_full = true;
	else
	{
		wq_enqueue(&t3->active_wq, get_queued(cgpu));
	}
	mutex_unlock(&t3->lock);

	return queue_full;
}

static void T3_flush_work(struct cgpu_info *cgpu)
{
	struct T3_chain *t3 = cgpu->device_data;
	int cid = t3->chain_id;
	//board_selector->select(cid);
	int i;

	mutex_lock(&t3->lock);
	/* stop chips hashing current work */
	if (!abort_work(t3)) 
	{
		applog(LOG_ERR, "%d: failed to abort work in chip chain!", cid);
	}
	/* flush the work chips were currently hashing */
	for (i = 0; i < t3->num_active_chips; i++) 
	{
		int j;
		struct T3_chip *chip = &t3->chips[i];
		for (j = 0; j < 4; j++)
		{
			struct work *work = chip->work[j];
			if (work == NULL)
				continue;
			//applog(LOG_DEBUG, "%d: flushing chip %d, work %d: 0x%p",
			//       cid, i, j + 1, work);
			work_completed(cgpu, work);
			chip->work[j] = NULL;
		}

		chip->last_queued_id = 0;

		if(!inno_cmd_resetjob(t3, i + 1))
		{
			applog(LOG_WARNING, "chip %d clear work false", i + 1);
			continue;
		}

		//applog(LOG_INFO, "chip :%d flushing queued work success", i);
	}
	/* flush queued work */
	//applog(LOG_DEBUG, "%d: flushing queued work...", cid);
	while (t3->active_wq.num_elems > 0) 
	{
		struct work *work = wq_dequeue(&t3->active_wq);
		assert(work != NULL);
		work_completed(cgpu, work);
	}
	mutex_unlock(&t3->lock);

}

static bool bitmain_DASH_prepare(struct thr_info *thr)
{
	return true;
}

static void T3_get_statline_before(char *buf, size_t len, struct cgpu_info *cgpu)
{
	struct T3_chain *t3 = cgpu->device_data;
	char temp[10];
	if (t3->temp != 0)
		snprintf(temp, 9, "%2dC", t3->temp);
	tailsprintf(buf, len, " %2d:%2d/%3d %s",
		    t3->chain_id, t3->num_active_chips, t3->num_cores,
		    t3->temp == 0 ? "   " : temp);
}

struct device_drv bitmineA1_drv = {
	.drv_id = DRIVER_bitmineA1,
	.dname = "BitmineA1",
	.name = "BA1",
	.drv_detect = T3_detect,
	.thread_prepare = bitmain_DASH_prepare,
	.hash_work = hash_queued_work,
	.scanwork = T3_scanwork,
	.queue_full = T3_queue_full,
	.flush_work = T3_flush_work,
	.get_statline_before = T3_get_statline_before,
};

